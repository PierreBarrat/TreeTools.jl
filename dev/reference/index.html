<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>- · TreeTools</title><meta name="title" content="- · TreeTools"/><meta property="og:title" content="- · TreeTools"/><meta property="twitter:title" content="- · TreeTools"/><meta name="description" content="Documentation for TreeTools."/><meta property="og:description" content="Documentation for TreeTools."/><meta property="twitter:description" content="Documentation for TreeTools."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="TreeTools logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">TreeTools</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../basic_concepts/">Basic concepts</a></li><li><a class="tocitem" href="../IO/">Reading and writing</a></li><li><a class="tocitem" href="../Iteration/">Iteration</a></li><li><a class="tocitem" href="../useful_functions/">Useful functions</a></li><li><a class="tocitem" href="../modifying_the_tree/">Modifying the tree</a></li><li><a class="tocitem" href="../generating_trees/">Generating trees</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>-</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>-</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/PierreBarrat/TreeTools.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/PierreBarrat/TreeTools.jl/blob/master/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><p>Documentation for <a href="https://github.com/PierreBarrat/TreeTools.jl">TreeTools</a>.</p><ul><li><a href="#TreeTools.Generate.YuleCoalescent"><code>TreeTools.Generate.YuleCoalescent</code></a></li><li><a href="#TreeTools.MiscData"><code>TreeTools.MiscData</code></a></li><li><a href="#TreeTools.Split"><code>TreeTools.Split</code></a></li><li><a href="#TreeTools.SplitList"><code>TreeTools.SplitList</code></a></li><li><a href="#TreeTools.Tree"><code>TreeTools.Tree</code></a></li><li><a href="#TreeTools.TreeNode"><code>TreeTools.TreeNode</code></a></li><li><a href="#TreeTools.TreeNodeData"><code>TreeTools.TreeNodeData</code></a></li><li><a href="#Base.insert!-Union{Tuple{T}, Tuple{Tree{T}, TreeNode}} where T"><code>Base.insert!</code></a></li><li><a href="#TreeTools.Generate.balanced_binary_tree"><code>TreeTools.Generate.balanced_binary_tree</code></a></li><li><a href="#TreeTools.Generate.birth_death-Tuple{Integer, Real, Real}"><code>TreeTools.Generate.birth_death</code></a></li><li><a href="#TreeTools.Generate.genealogy-Tuple{TreeTools.Generate.Coalescent}"><code>TreeTools.Generate.genealogy</code></a></li><li><a href="#TreeTools.Generate.ladder_tree"><code>TreeTools.Generate.ladder_tree</code></a></li><li><a href="#TreeTools.Generate.star_tree"><code>TreeTools.Generate.star_tree</code></a></li><li><a href="#TreeTools.arecompatible-Tuple{Split, Split}"><code>TreeTools.arecompatible</code></a></li><li><a href="#TreeTools.branch_length!-Tuple{TreeNode, Union{Missing, Real}}"><code>TreeTools.branch_length!</code></a></li><li><a href="#TreeTools.check_tree-Tuple{Tree}"><code>TreeTools.check_tree</code></a></li><li><a href="#TreeTools.data!-Union{Tuple{T}, Tuple{TreeNode{T}, T}} where T"><code>TreeTools.data!</code></a></li><li><a href="#TreeTools.distance-Tuple{Tree, Tree}"><code>TreeTools.distance</code></a></li><li><a href="#TreeTools.distance-Tuple{TreeNode, TreeNode}"><code>TreeTools.distance</code></a></li><li><a href="#TreeTools.graft!-Union{Tuple{T}, Tuple{Tree{T}, TreeNode{T}, TreeNode}} where T"><code>TreeTools.graft!</code></a></li><li><a href="#TreeTools.internals"><code>TreeTools.internals</code></a></li><li><a href="#TreeTools.is_ancestor-Tuple{TreeNode, TreeNode}"><code>TreeTools.is_ancestor</code></a></li><li><a href="#TreeTools.iscompatible"><code>TreeTools.iscompatible</code></a></li><li><a href="#TreeTools.isleaf-Tuple{Split}"><code>TreeTools.isleaf</code></a></li><li><a href="#TreeTools.isroot-Tuple{SplitList, Any}"><code>TreeTools.isroot</code></a></li><li><a href="#TreeTools.isroot-Tuple{Split, Any}"><code>TreeTools.isroot</code></a></li><li><a href="#TreeTools.label!-Tuple{Tree, TreeNode, AbstractString}"><code>TreeTools.label!</code></a></li><li><a href="#TreeTools.label!-Tuple{Tree, AbstractString}"><code>TreeTools.label!</code></a></li><li><a href="#TreeTools.lca-Tuple{Vararg{TreeNode}}"><code>TreeTools.lca</code></a></li><li><a href="#TreeTools.lca-Tuple{Tree, Any}"><code>TreeTools.lca</code></a></li><li><a href="#TreeTools.lca-Tuple{TreeNode, TreeNode}"><code>TreeTools.lca</code></a></li><li><a href="#TreeTools.leaves-Tuple{SplitList, Any}"><code>TreeTools.leaves</code></a></li><li><a href="#TreeTools.leaves"><code>TreeTools.leaves</code></a></li><li><a href="#TreeTools.node2tree-Union{Tuple{TreeNode{T}}, Tuple{T}} where T"><code>TreeTools.node2tree</code></a></li><li><a href="#TreeTools.node_depth-Tuple{TreeNode}"><code>TreeTools.node_depth</code></a></li><li><a href="#TreeTools.nodes"><code>TreeTools.nodes</code></a></li><li><a href="#TreeTools.parse_newick_string-Tuple{AbstractString}"><code>TreeTools.parse_newick_string</code></a></li><li><a href="#TreeTools.postorder_traversal-Tuple{Function, TreeNode}"><code>TreeTools.postorder_traversal</code></a></li><li><a href="#TreeTools.print_tree_ascii-Tuple{Any, Tree}"><code>TreeTools.print_tree_ascii</code></a></li><li><a href="#TreeTools.prune!-Tuple{Any, Any}"><code>TreeTools.prune!</code></a></li><li><a href="../IO/#TreeTools.read_tree"><code>TreeTools.read_tree</code></a></li><li><a href="#TreeTools.read_tree-Tuple{IO}"><code>TreeTools.read_tree</code></a></li><li><a href="#TreeTools.root!-Tuple{Tree, AbstractString}"><code>TreeTools.root!</code></a></li><li><a href="#TreeTools.root!-Tuple{Any}"><code>TreeTools.root!</code></a></li><li><a href="#TreeTools.share_labels-Tuple{Any, Any}"><code>TreeTools.share_labels</code></a></li><li><a href="#TreeTools.traversal"><code>TreeTools.traversal</code></a></li><li><a href="#TreeTools.write_newick-Tuple{IO, Tree}"><code>TreeTools.write_newick</code></a></li><li><a href="#TreeTools.write_newick-Tuple{Tree}"><code>TreeTools.write_newick</code></a></li></ul><article><details class="docstring" open="true"><summary id="TreeTools.MiscData"><a class="docstring-binding" href="#TreeTools.MiscData"><code>TreeTools.MiscData</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct MiscData &lt;: TreeNodeData
	dat::Dict{Any,Any}
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/objects.jl#L14-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.Split"><a class="docstring-binding" href="#TreeTools.Split"><code>TreeTools.Split</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Split</code></pre><p><code>dat::Array{Int,1}</code>: indices of leaves in the split</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/splits.jl#L5-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.SplitList"><a class="docstring-binding" href="#TreeTools.SplitList"><code>TreeTools.SplitList</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SplitList{T}</code></pre><ul><li><code>leaves::Array{T,1}</code>: labels of leaves</li><li><code>splits::Array{Split,1}</code></li><li><code>mask::Array{Bool,1}</code>: subset of leaves for which splits apply.</li><li><code>splitmap::Dict{T,Split}</code>: indicate the split corresponding to the branch above a node. Only initialized if built from a tree with labels on internal nodes.</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">SplitList(leaves::Array{T,1}) where T</code></pre><p>Empty <code>SplitList</code>.</p><pre><code class="language-julia hljs">SplitList(t::Tree[, mask])</code></pre><p>List of splits in <code>t</code>. <code>mask</code> defaults to ones.</p><pre><code class="language-julia hljs">SplitList(r::TreeNode, leaves[, mask])</code></pre><p>Compute the list of splits below <code>r</code>, including <code>r</code> itself.   Assume that <code>r</code> is part of a tree with <code>leaves</code>. <code>mask</code> defaults to the set of leaves that are descendents   of <code>r</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/splits.jl#L216-L240">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.Tree"><a class="docstring-binding" href="#TreeTools.Tree"><code>TreeTools.Tree</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">mutable struct Tree{T &lt;: TreeNodeData}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/objects.jl#L133-L135">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.TreeNode"><a class="docstring-binding" href="#TreeTools.TreeNode"><code>TreeTools.TreeNode</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">mutable struct TreeNode{T &lt;: TreeNodeData}</code></pre><p>Structural information on the tree, <em>i.e.</em> topology and branch length.</p><ul><li><code>anc::Union{Nothing,TreeNode}</code>: Ancestor</li><li><code>child::Array{TreeNode,1}</code>: List of children</li><li><code>isleaf::Bool</code></li><li><code>isroot::Bool</code></li><li><code>tau::Union{Missing, Float64}</code></li><li><code>data::T</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/objects.jl#L47-L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.TreeNodeData"><a class="docstring-binding" href="#TreeTools.TreeNodeData"><code>TreeTools.TreeNodeData</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">abstract type TreeNodeData</code></pre><p>Abstract supertype for data attached to the <code>dat</code> field of <code>TreeNode</code> objects. Implemented concrete types are</p><ul><li><code>EmptyData</code>: empty struct. Use if you do not have to attach data to nodes.</li><li><code>MiscData</code>: contains a dictionary for attaching extra data to nodes. Also behaves like  a <code>Dict</code> for indexing/iterating, <em>e.g.</em> <code>x.dat[key] == x[key]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/objects.jl#L1-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.insert!-Union{Tuple{T}, Tuple{Tree{T}, TreeNode}} where T"><a class="docstring-binding" href="#Base.insert!-Union{Tuple{T}, Tuple{Tree{T}, TreeNode}} where T"><code>Base.insert!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">insert!(tree, node; name, time)</code></pre><p>Insert a singleton named <code>name</code> above <code>node</code>, at height <code>time</code> on the branch. Return the inserted singleton. <code>time</code> can be a <code>Number</code> or <code>missing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/prunegraft.jl#L312-L318">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.arecompatible-Tuple{Split, Split}"><a class="docstring-binding" href="#TreeTools.arecompatible-Tuple{Split, Split}"><code>TreeTools.arecompatible</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">arecompatible(s::Split, t::Split[, mask::Array{Bool}])</code></pre><p>Are splits <code>s</code> and <code>t</code> compatible <strong>in the cluster sense</strong>.</p><pre><code class="language-julia hljs">arecompatible(s::SplitList, i::Integer, j::Integer; mask=true)</code></pre><p>Are <code>s.splits[i]</code> and <code>s.splits[j]</code> compatible <strong>in the cluster sense</strong>?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/splits.jl#L428-L436">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.branch_length!-Tuple{TreeNode, Union{Missing, Real}}"><a class="docstring-binding" href="#TreeTools.branch_length!-Tuple{TreeNode, Union{Missing, Real}}"><code>TreeTools.branch_length!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">branch_length!(n::TreeNode, τ)</code></pre><p>Set the branch length above <code>n</code> to <code>τ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/objects.jl#L115-L119">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.check_tree-Tuple{Tree}"><a class="docstring-binding" href="#TreeTools.check_tree-Tuple{Tree}"><code>TreeTools.check_tree</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">check_tree(t::Tree; strict=true)</code></pre><ul><li>Every non-leaf node should have at least one child (two if <code>strict</code>)</li><li>Every non-root node should have exactly one ancestor</li><li>If n.child[...] == c, c.anc == n is true</li><li>Tree has only one root</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/misc.jl#L182-L189">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.data!-Union{Tuple{T}, Tuple{TreeNode{T}, T}} where T"><a class="docstring-binding" href="#TreeTools.data!-Union{Tuple{T}, Tuple{TreeNode{T}, T}} where T"><code>TreeTools.data!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">data!(n::TreeNode{T}, dat::T)</code></pre><p>Set the the data field of <code>n</code> to <code>dat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/objects.jl#L126-L130">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.distance-Tuple{Tree, Tree}"><a class="docstring-binding" href="#TreeTools.distance-Tuple{Tree, Tree}"><code>TreeTools.distance</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">distance(t1::Tree, t2::Tree; type = :RF, normalize = false)</code></pre><p>Compute distance between two trees. See <code>TreeTools.tree_distance_types</code> for allowed types. If <code>normalize</code>, the distance is normalized to <code>[0,1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/methods.jl#L946-L952">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.distance-Tuple{TreeNode, TreeNode}"><a class="docstring-binding" href="#TreeTools.distance-Tuple{TreeNode, TreeNode}"><code>TreeTools.distance</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">distance(t::Tree, n1::AbstractString, n2::AbstractString; topological=false)
distance(n1::TreeNode, n2::TreeNode; topological=false)</code></pre><p>Compute branch length distance between <code>n1</code> and <code>n2</code> by summing the <code>branch_length</code> values. If <code>topological</code>, the value <code>1.</code> is summed instead, counting the number of branches separating the two nodes (<em>Note</em>: the output is not an <code>Int</code>!).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/methods.jl#L437-L444">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.graft!-Union{Tuple{T}, Tuple{Tree{T}, TreeNode{T}, TreeNode}} where T"><a class="docstring-binding" href="#TreeTools.graft!-Union{Tuple{T}, Tuple{Tree{T}, TreeNode{T}, TreeNode}} where T"><code>TreeTools.graft!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">graft!(tree::Tree, n, r; graft_on_leaf=false, time=branch_length(n))</code></pre><p>Graft <code>n</code> onto <code>r</code> and return the grafted node. <code>r</code> can be a label or a <code>TreeNode</code>, and should belong to <code>tree</code>. <code>n</code> can be a <code>TreeNode</code> or a <code>Tree</code>. In the latter case, <code>n</code> will be <em>copied</em> before being grafted. None of the nodes of the subtree of <code>n</code> should belong to <code>tree</code>.</p><p>If <code>r</code> is a leaf and <code>graft_on_leaf</code> is set to <code>false</code> (default), will raise an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/prunegraft.jl#L171-L181">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.internals"><a class="docstring-binding" href="#TreeTools.internals"><code>TreeTools.internals</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">nodes(t; skiproot=false)
leaves(t)
internals(t; skiproot=false)</code></pre><p>Iterator over all nodes / leaves / internal nodes of a tree. If <code>skiproot</code>, the root node will be skipped by the iterator.</p><p><strong>Note</strong></p><p><code>length</code> cannot be called on <code>internals(t)</code> as the latter is based on <code>Iterators.filter</code>.   A way to get the number of internal nodes of a tree is for example by calling   <code>length(nodes(t)) - length(leaves(t))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/iterators.jl#L5-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.is_ancestor-Tuple{TreeNode, TreeNode}"><a class="docstring-binding" href="#TreeTools.is_ancestor-Tuple{TreeNode, TreeNode}"><code>TreeTools.is_ancestor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_ancestor(t::Tree, a::AbstractString, n::AbstractString)
is_ancestor(a::TreeNode, n::TreeNode)</code></pre><p>Check if <code>a</code> is an ancestor of <code>n</code>, in the sense that <code>ancestor(ancestor(...(node))) == a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/methods.jl#L467-L472">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.iscompatible"><a class="docstring-binding" href="#TreeTools.iscompatible"><code>TreeTools.iscompatible</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">iscompatible(s::Split, S::SplitList, mask=S.mask; usemask=true)</code></pre><p>Is <code>s</code> compatible with all splits in <code>S</code>?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/splits.jl#L463-L467">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.isleaf-Tuple{Split}"><a class="docstring-binding" href="#TreeTools.isleaf-Tuple{Split}"><code>TreeTools.isleaf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isleaf(s::Split)
isleaf(s::Split, mask::Array{Bool,1})</code></pre><p>Check if <code>s</code> is a leaf split.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/splits.jl#L91-L96">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.isroot-Tuple{Split, Any}"><a class="docstring-binding" href="#TreeTools.isroot-Tuple{Split, Any}"><code>TreeTools.isroot</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isroot(s::Split, mask::Array{Bool,1})</code></pre><p>Check if <code>s</code> is the root split when restricted to <code>mask</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/splits.jl#L71-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.isroot-Tuple{SplitList, Any}"><a class="docstring-binding" href="#TreeTools.isroot-Tuple{SplitList, Any}"><code>TreeTools.isroot</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isroot(S::SplitList, i)</code></pre><p>Is <code>S[i]</code> the root?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/splits.jl#L308-L312">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.label!-Tuple{Tree, AbstractString}"><a class="docstring-binding" href="#TreeTools.label!-Tuple{Tree, AbstractString}"><code>TreeTools.label!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">label!(t::Tree, label::AbstractString)</code></pre><p>Change the label of the <code>Tree</code> to <code>label</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/objects.jl#L160-L164">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.label!-Tuple{Tree, TreeNode, AbstractString}"><a class="docstring-binding" href="#TreeTools.label!-Tuple{Tree, TreeNode, AbstractString}"><code>TreeTools.label!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">label!(t::Tree, node::TreeNode, new_label::AbstractString)
label!(t::Tree, old_label, new_label)</code></pre><p>Change the label of a <code>TreeNode</code> to <code>new_label</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/objects.jl#L166-L171">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.lca-Tuple{Tree, Any}"><a class="docstring-binding" href="#TreeTools.lca-Tuple{Tree, Any}"><code>TreeTools.lca</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lca(t::Tree, labels::Array{&lt;:AbstractString,1})
lca(t::Tree, labels...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/methods.jl#L404-L407">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.lca-Tuple{TreeNode, TreeNode}"><a class="docstring-binding" href="#TreeTools.lca-Tuple{TreeNode, TreeNode}"><code>TreeTools.lca</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lca(i_node::TreeNode, j_node::TreeNode)</code></pre><p>Find and return lowest common ancestor of <code>i_node</code> and <code>j_node</code>. Idea is to go up in the tree in an asymmetric way on the side of the deeper node, until both are at equal distance from root. Then, problem is solved by going up in a symmetric way. (https://stackoverflow.com/questions/1484473/how-to-find-the-lowest-common-ancestor-of-two-nodes-in-any-binary-tree/6183069#6183069)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/methods.jl#L354-L359">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.lca-Tuple{Vararg{TreeNode}}"><a class="docstring-binding" href="#TreeTools.lca-Tuple{Vararg{TreeNode}}"><code>TreeTools.lca</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lca(nodelist)</code></pre><p>Find the common ancestor of all nodes in <code>nodelist</code>. <code>nodelist</code> is an iterable collection of <code>TreeNode</code> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/methods.jl#L388-L392">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.leaves"><a class="docstring-binding" href="#TreeTools.leaves"><code>TreeTools.leaves</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">nodes(t; skiproot=false)
leaves(t)
internals(t; skiproot=false)</code></pre><p>Iterator over all nodes / leaves / internal nodes of a tree. If <code>skiproot</code>, the root node will be skipped by the iterator.</p><p><strong>Note</strong></p><p><code>length</code> cannot be called on <code>internals(t)</code> as the latter is based on <code>Iterators.filter</code>.   A way to get the number of internal nodes of a tree is for example by calling   <code>length(nodes(t)) - length(leaves(t))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/iterators.jl#L5-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.leaves-Tuple{SplitList, Any}"><a class="docstring-binding" href="#TreeTools.leaves-Tuple{SplitList, Any}"><code>TreeTools.leaves</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">leaves(S::SplitList, i)</code></pre><p>Return array of leaves in <code>S.splits[i]</code>, taking <code>S.mask</code> into account.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/splits.jl#L315-L319">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.node2tree-Union{Tuple{TreeNode{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#TreeTools.node2tree-Union{Tuple{TreeNode{T}}, Tuple{T}} where T"><code>TreeTools.node2tree</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">node2tree(root::TreeNode{T}; label = default_tree_label(), force_new_labels=false)</code></pre><p>Create a <code>Tree</code> object from <code>root</code> with name <code>label</code>. If <code>force_new_labels</code>, a random string is added to node labels to make them unique.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/methods.jl#L5-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.node_depth-Tuple{TreeNode}"><a class="docstring-binding" href="#TreeTools.node_depth-Tuple{TreeNode}"><code>TreeTools.node_depth</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">node_depth(node::TreeNode)</code></pre><p>Topologic distance from <code>node</code> to root.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/methods.jl#L339-L343">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.nodes"><a class="docstring-binding" href="#TreeTools.nodes"><code>TreeTools.nodes</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">nodes(t; skiproot=false)
leaves(t)
internals(t; skiproot=false)</code></pre><p>Iterator over all nodes / leaves / internal nodes of a tree. If <code>skiproot</code>, the root node will be skipped by the iterator.</p><p><strong>Note</strong></p><p><code>length</code> cannot be called on <code>internals(t)</code> as the latter is based on <code>Iterators.filter</code>.   A way to get the number of internal nodes of a tree is for example by calling   <code>length(nodes(t)) - length(leaves(t))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/iterators.jl#L5-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.parse_newick_string-Tuple{AbstractString}"><a class="docstring-binding" href="#TreeTools.parse_newick_string-Tuple{AbstractString}"><code>TreeTools.parse_newick_string</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parse_newick_string(
	nw::AbstractString;
	node_data_type=DEFAULT_NODE_DATATYPE, force_new_labels=false
)</code></pre><p>Parse newick string into a tree. See <code>read_tree</code> for more informations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/reading.jl#L60-L67">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.postorder_traversal-Tuple{Function, TreeNode}"><a class="docstring-binding" href="#TreeTools.postorder_traversal-Tuple{Function, TreeNode}"><code>TreeTools.postorder_traversal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">postorder_traversal([f], tree; root=true, leaves=true, internals=true)</code></pre><p>Traverse <code>tree</code> in postorder, iterating over nodes. The children of <code>node</code> are returned in the same order as <code>children(node)</code>.</p><p>Keep only nodes <code>n</code> such that <code>f(n)</code> is true. If <code>leaves</code>, <code>internals</code> or <code>root</code> are set to <code>false</code>, the corresponding nodes are excluded.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">for node in postorder_traversal(tree; root=false)
    isroot(node) # always false
end

[label(x) for x in postorder_traversal(tree; internals=false)] # labels of leaf nodes</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/iterators.jl#L51-L68">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.print_tree_ascii-Tuple{Any, Tree}"><a class="docstring-binding" href="#TreeTools.print_tree_ascii-Tuple{Any, Tree}"><code>TreeTools.print_tree_ascii</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">print_tree_ascii(io, t::Tree)</code></pre><p>Julia implementation of Bio.Phylo.draw<em>ascii function:  https://github.com/biopython/biopython/blob/master/Bio/Phylo/</em>utils.py</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/misc.jl#L90-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.prune!-Tuple{Any, Any}"><a class="docstring-binding" href="#TreeTools.prune!-Tuple{Any, Any}"><code>TreeTools.prune!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">prune!(tree, node; kwargs...)
prune!(tree, labels::AbstractArray)
prune!(tree, labels...)</code></pre><p>Prune <code>node</code> from <code>tree</code>. <code>node</code> can be a label or a <code>TreeNode</code>. Return the subtree defined by <code>node</code> as a <code>Tree</code> object as well as the previous ancestor of <code>node</code>.</p><p>If a list of labels is provided, the MRCA of the corresponding nodes is pruned.</p><p><strong>kwargs</strong></p><ul><li><code>remove_singletons</code>: remove singletons (internals with one child) in the tree after pruning. Default <code>true</code>.</li><li><code>clade_only</code>: if a list of labels is provided, check that it corresponds to a clade before pruning. Default <code>true</code>.</li><li><code>create_leaf</code>: if the ancestor of <code>r</code> has only one child (singleton), pruning <code>r</code>  will create a leaf. If <code>create_leaf == :warn</code>, this will trigger a warning. If  <code>create_leaf = false</code>, it will trigger an error. If <code>create_leaf = true</code>, then this  is allowed. Default: <code>:warn</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using TreeTools # hide
tree = parse_newick_string(&quot;(A:1.,(B:1.,(X1:0.,X2:0.)X:5.)BX:1.)R;&quot;)
prune!(tree, [&quot;X1&quot;, &quot;X2&quot;])
map(label, nodes(tree))

# output

3-element Vector{String}:
 &quot;B&quot;
 &quot;A&quot;
 &quot;R&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/prunegraft.jl#L127-L161">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.read_tree-Tuple{IO}"><a class="docstring-binding" href="#TreeTools.read_tree-Tuple{IO}"><code>TreeTools.read_tree</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">read_tree(
	nwk_filename::AbstractString;
	node_data_type=DEFAULT_NODE_DATATYPE,
    label,
    force_new_labels=false,
    check=true,
)
read_tree(io::IO; kwargs...)</code></pre><p>Read Newick file and create a <code>Tree{node_data_type}</code> object from it. If the input file contains multiple Newick strings on different lines, the output is an array of <code>Tree</code> objects.</p><p>The call <code>node_data_type()</code> must return a valid instance of a subtype of <code>TreeNodeData</code>. You can implement your own subtypes, or see <code>?TreeNodeData</code> for already implemented ones. The default is <code>EmptyData</code>.</p><p>Use <code>force_new_labels=true</code> to force the renaming of all internal nodes. By default the tree will be assigned a label by calling <code>default_tree_label()</code>. This can be changed using the <code>label</code> argument.</p><p>If you have a variable containing a Newick string and want to build a tree from it, use <code>parse_newick_string</code> instead.</p><p><strong>Note on labels</strong></p><p>The <code>Tree</code> type identifies nodes by their labels. This means that labels have to be unique. For this reason, the following is done when reading a tree:</p><ul><li>if an internal node does not have a label, a unique one will be created of the form  <code>&quot;NODE_i&quot;</code></li><li>if a node has a label that was already found before in the tree, a random identifier  will be appended to it to make it unique. Note that the identifier is created using  <code>randstring(8)</code>, unicity is technically not guaranteed.</li><li>if <code>force_new_labels</code> is used, a unique identifier is appended to node labels</li><li>if node labels in the Newick file are identified as confidence/bootstrap values, a random  identifier is appended to them, even if they&#39;re unique in the tree. See  <code>?TreeTools.isbootstrap</code> to see which labels are identified as confidence values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/reading.jl#L11-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.root!-Tuple{Any}"><a class="docstring-binding" href="#TreeTools.root!-Tuple{Any}"><code>TreeTools.root!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">root!(tree; method=:midpoint, topological = false)</code></pre><p>Root tree using <code>method</code>. Only implemented method is <code>:midpoint</code>. </p><p><strong>Methods</strong></p><p><strong><code>:midpoint</code></strong></p><p>Distance between nodes can be either topological (number of branches) or based on branch length. Does not create a polytomy at the root: if the midpoint is an already existing internal node (not the root), creates a new root node at infinitesimal distance below it.</p><p>Midpoint rooting will exit without doing anything if</p><ul><li>the distance between the two farthest leaves is <code>0</code>. This happens if all branch lengths  are 0.</li><li>the current root is already the midpoint.</li></ul><p><strong><code>:model</code></strong></p><p>Provide keyword argument <code>model::Tree</code>. Try to root <code>tree</code> like <code>model</code>. If the two trees only differ by rooting, they will have the same topology at the end of this. Else, tree will be rerooted but a warning will be given.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/methods.jl#L635-L659">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.root!-Tuple{Tree, AbstractString}"><a class="docstring-binding" href="#TreeTools.root!-Tuple{Tree, AbstractString}"><code>TreeTools.root!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">root!(tree::Tree, node::AbstractString; root_on_leaf, time=0., remove_singletons=true)</code></pre><p>Root <code>tree</code> at <code>tree.lnodes[node]</code>. Equivalent to outgroup rooting. If <code>time</code> is non-zero, root above <code>node</code> at height <code>time</code>, inserting a new node.</p><p>If <code>remove_singletons</code>, singleton nodes are removed after re-rooting. This is useful to remove the old root, which often ends up being a singleton.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/methods.jl#L592-L600">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.share_labels-Tuple{Any, Any}"><a class="docstring-binding" href="#TreeTools.share_labels-Tuple{Any, Any}"><code>TreeTools.share_labels</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">share_labels(tree1, tree2)</code></pre><p>Check if <code>tree1</code> and <code>tree2</code> share the same labels for leaf nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/methods.jl#L124-L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.traversal"><a class="docstring-binding" href="#TreeTools.traversal"><code>TreeTools.traversal</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">traversal([f], tree, style=:postorder; internals, leaves, root)
traversal([f], node, style=:postorder; internals, leaves, root)</code></pre><p>Iterate through nodes of <code>tree</code> according to <code>style</code>, skipping nodes for which <code>f</code> returns <code>false</code>. <code>style</code> must be in <code>collect(keys(TreeTools.traversal_styles))</code>. For now its just <code>:postorder</code>.</p><p>See <code>postorder_traversal</code> for extended docstring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/iterators.jl#L197-L207">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.write_newick-Tuple{IO, Tree}"><a class="docstring-binding" href="#TreeTools.write_newick-Tuple{IO, Tree}"><code>TreeTools.write_newick</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">write_newick(io::IO, tree::Tree; kwargs...)
write_newick(filename::AbstractString, tree::Tree, mode=&quot;w&quot;; kwargs...)
write_newick(tree::Tree; kwargs...)</code></pre><p>Write Newick string corresponding to <code>tree</code> to <code>io</code> or <code>filename</code>. If output is not provided, return the Newick string. If <code>internal_labels == false</code>, do not write labels of internal nodes in the string.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/writing.jl#L37-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.write_newick-Tuple{Tree}"><a class="docstring-binding" href="#TreeTools.write_newick-Tuple{Tree}"><code>TreeTools.write_newick</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">newick(tree::Tree; internal_labels=true, write_root=true)</code></pre><p>Return the Newick string correpsonding to <code>tree</code>. If <code>internal_labels == false</code>, do not write labels of internal nodes in the string. If <code>!write_root</code>, do not write label and time for the root node (unrooted tree).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/writing.jl#L57-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.Generate.YuleCoalescent"><a class="docstring-binding" href="#TreeTools.Generate.YuleCoalescent"><code>TreeTools.Generate.YuleCoalescent</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">mutable struct YuleCoalescent</code></pre><pre><code class="language-julia hljs">n::Int = 2
b::Float64 = 1 # birth rate</code></pre><p>Rate of coalescence <code>(n-1)b</code>. The expected height of the tree is (I think) <code>~log(n)/b</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/Generate/coalescent.jl#L18-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.Generate.balanced_binary_tree"><a class="docstring-binding" href="#TreeTools.Generate.balanced_binary_tree"><code>TreeTools.Generate.balanced_binary_tree</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">balanced_binary_tree(n::Integer, time::Union{Missing, Real} = missing)</code></pre><p>Return a balanced binary tree of <code>n</code> nodes with all branches of length <code>time</code>. <code>n</code> must be a power of 2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/Generate/simple_shapes.jl#L58-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.Generate.birth_death-Tuple{Integer, Real, Real}"><a class="docstring-binding" href="#TreeTools.Generate.birth_death-Tuple{Integer, Real, Real}"><code>TreeTools.Generate.birth_death</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">birth_death(n::Integer, λ::Real, μ::Real; active=false, warn_incomplete=true)</code></pre><p>Simulate a birth death process with rates <code>λ</code> (birth) and <code>μ</code> (death). Stop when there are <code>n</code> lineages. Return the a <code>Tree</code> and a boolean indicating completion of the process: it is <code>false</code> if all lineages died before reaching the target <code>n</code>.</p><p>Keyword argument <code>active</code> (default: <code>false</code>) controls whether only active lineages (<em>i.e.</em> non dead) count towards completion. If <code>active=false</code>, the number of leaves of output tree is <code>n</code> if the process completed. If <code>active=true</code>, it is larger than <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/Generate/birth_death.jl#L1-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.Generate.genealogy-Tuple{TreeTools.Generate.Coalescent}"><a class="docstring-binding" href="#TreeTools.Generate.genealogy-Tuple{TreeTools.Generate.Coalescent}"><code>TreeTools.Generate.genealogy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">genealogy(C::Coalescent; coalescence_times = false)</code></pre><p>Return a tree sampled from the coalescent <code>C</code>. If <code>coalescence_times</code>, also return the times <code>Tn</code> during which <code>n</code> lineages are present, in the form of a dictionary <code>n =&gt; Tn</code>.</p><p><strong>Examples</strong></p><p>For the Kingman coalescent with population size <code>N</code> and <code>n=100</code> lineages:</p><pre><code class="language-julia hljs">tree = genealogy(KingmanCoalescent(100, N))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/Generate/coalescent.jl#L102-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.Generate.ladder_tree"><a class="docstring-binding" href="#TreeTools.Generate.ladder_tree"><code>TreeTools.Generate.ladder_tree</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ladder_tree(n[, t=missing])</code></pre><p>Return a ladder tree with <code>n</code> leaves with total height <code>t</code>. For 4 leaves <code>A, B, C, D</code>, this would be <code>(A:t,(B:2t/3,(C:t/3,D:t/3)));</code>. The elementary branch length is <code>t/(n-1)</code> if <code>n&gt;1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/Generate/simple_shapes.jl#L22-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="TreeTools.Generate.star_tree"><a class="docstring-binding" href="#TreeTools.Generate.star_tree"><code>TreeTools.Generate.star_tree</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">star_tree(n, times)</code></pre><p>Create a star tree with <code>n</code> leaves. <code>times</code> can be an iterable of length <code>n</code> or a number/missing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PierreBarrat/TreeTools.jl/blob/24217bb26b74a93eb1060df85dfc50d378221455/src/Generate/simple_shapes.jl#L1-L6">source</a></section></details></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 13 January 2026 12:55">Tuesday 13 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
