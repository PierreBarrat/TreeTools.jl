<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basic concepts · TreeTools</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="TreeTools logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">TreeTools</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Basic concepts</a><ul class="internal"><li><a class="tocitem" href="#TreeNode"><span>TreeNode</span></a></li><li><a class="tocitem" href="#TreeNodeData"><span>TreeNodeData</span></a></li><li><a class="tocitem" href="#Tree"><span>Tree</span></a></li></ul></li><li><a class="tocitem" href="../IO/">Reading and writing</a></li><li><a class="tocitem" href="../Iteration/">Iteration</a></li><li><a class="tocitem" href="../useful_functions/">Useful functions</a></li><li><a class="tocitem" href="../modifying_the_tree/">Modifying the tree</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Basic concepts</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Basic concepts</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PierreBarrat/TreeTools.jl/blob/master/docs/src/basic_concepts.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Basic-concepts"><a class="docs-heading-anchor" href="#Basic-concepts">Basic concepts</a><a id="Basic-concepts-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-concepts" title="Permalink"></a></h1><p>To introduce basic concepts and data structures used in TreeTools, we will use the small tree given by this <a href="https://en.wikipedia.org/wiki/Newick_format">Newick string</a>: <code>&quot;((A:1,B:1)AB:2,C:3)R;&quot;</code>. To obtain a tree from the string, run the following code in a julia REPL: </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using TreeTools</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nwk = &quot;((A:1,B:1)AB:2,C:3)R;&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;((A:1,B:1)AB:2,C:3)R;&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tree = parse_newick_string(nwk)</code><code class="nohighlight hljs ansi" style="display:block;">
                                                     _________________________ A
  __________________________________________________|
_|                                                  |_________________________ B
 |
 |____________________________________________________________________________ C</code></pre><h2 id="TreeNode"><a class="docs-heading-anchor" href="#TreeNode">TreeNode</a><a id="TreeNode-1"></a><a class="docs-heading-anchor-permalink" href="#TreeNode" title="Permalink"></a></h2><p>At the basic level, the tree is represented by a set of linked <code>TreeNode</code> structures. A node <code>n</code> contains the following information: </p><ul><li><code>ancestor(n)</code> returns the node above <code>n</code>. If <code>n</code> is the root, <code>ancestor(n)</code> returns <code>nothing</code>. </li><li><code>children(n)</code> returns an array containing all the nodes below <code>n</code>. If <code>n</code> is a leaf, <code>children(n)</code> is empty. </li><li><code>label(n)</code> returns the label of <code>n</code>, which also serves as an identifier of <code>n</code> in many TreeTools functions. See the warning below. </li><li><code>branch_length(n)</code> returns the length of the branch above <code>n</code> as a <code>Float64</code>. If <code>n</code> is the root or if it does not have a branch length, it returns <code>missing</code>. </li><li><code>data(n)</code> returns data attached to <code>n</code>, see <a href="#TreeNodeData">TreeNodeData</a></li><li><code>isroot(n)</code> and <code>isleaf(n)</code> are boolean functions with explicit behavior. </li></ul><div class="admonition is-warning"><header class="admonition-header">Node labels</header><div class="admonition-body"><p>TreeTools generally uses the label of nodes as an identifier. This is visible in the <code>Tree</code> structure which uses node labels for indexing. Another example is the equality between <code>TreeNode</code> objects <code>n1 == n2</code>, which simply falls back to <code>label(n1) == label(n2)</code>. For this reason, it is <strong>strongly discouraged</strong> to directly change the label of a node, <em>e.g.</em> by doing something like <code>n.label = mylabel</code>. A function <code>label!</code> is provided for that, called like this: <code>label!(tree, n, mylabel)</code>. This makes sure that the struct <code>tree</code> is informed about the label change. </p></div></div><div class="admonition is-danger"><header class="admonition-header">Loops in the tree</header><div class="admonition-body"><p>TreeTools does not actively enforce the fact that trees do not have loops. That is, if you try to, you can perfectly create a state where <em>e.g.</em> a node is its own ancestor. This will of course result in a lot of issues. I&#39;d like to enforce the absence of loops at some point, but for now it&#39;s up to the user to be careful.  </p></div></div><p>The illustration below is a summary of the <code>TreeNode</code> object.  <img src="../assets/TreeNode_illustration.png" alt="TreeNode_illustration"/></p><p>Each <code>TreeNode</code> can be accessed by directly indexing into the tree: </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; AB = tree[&quot;AB&quot;]</code><code class="nohighlight hljs ansi" style="display:block;">Node AB:
Ancestor: R, branch length = 2.0
2 children: [&quot;A&quot;, &quot;B&quot;]</code></pre><p>Testing this on the above example would give: </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; println(&quot;The ancestor of $(label(AB)) is $(label(ancestor(AB))), at distance $(branch_length(AB))&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">The ancestor of AB is R, at distance 2.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; println(&quot;Children of $(label(AB)): &quot;, map(label, children(AB)))</code><code class="nohighlight hljs ansi" style="display:block;">Children of AB: [&quot;A&quot;, &quot;B&quot;]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isleaf(AB)</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; map(isleaf, children(AB))</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{Bool}:
 1
 1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isroot(ancestor(AB))</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>Changing the value of the branch length or of the data attached to a node is done using the <code>branch_length!</code> and <code>data!</code> functions: </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; branch_length!(AB, 4.)</code><code class="nohighlight hljs ansi" style="display:block;">4.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; println(&quot;The distance from $(label(AB)) to $(label(ancestor(AB))) is now $(branch_length(AB))&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">The distance from AB to R is now 4.0</code></pre><div class="admonition is-info"><header class="admonition-header">Branches</header><div class="admonition-body"><p>TreeTools has no structure or type to represent branches.  Since only rooted trees are considered, it is natural for each node to &quot;own&quot; the branch above it.  As a result, informations about branches are expected  to be stored on the node below, as is the case for the branch length.</p></div></div><h2 id="TreeNodeData"><a class="docs-heading-anchor" href="#TreeNodeData">TreeNodeData</a><a id="TreeNodeData-1"></a><a class="docs-heading-anchor-permalink" href="#TreeNodeData" title="Permalink"></a></h2><p>TreeTools gives the possibility to attach data to nodes.  The <code>TreeNode</code> type is parametric: if data of type <code>D</code> is attached to a node, its type will be <code>TreeNode{D}</code>.  Children and ancestor of a <code>TreeNode{D}</code> object must also be of the <code>TreeNode{D}</code> type.  This implies that <em>all nodes in the tree must have the same type of data attached to them</em>. </p><p>The data type <code>D</code> has to be a subtype of the abstract type <code>TreeNodeData</code>.  The creation of nodes with a given data type is controlled by the <code>node_data_type</code> keyword argument in functions like <code>parse_newick_string</code> or <code>read_tree</code> (see the <a href="../IO/#Reading-and-writing">Reading and writing</a> page).  Two subtypes of <code>TreeNodeData</code> are already implemented in TreeTools. </p><ul><li><code>EmptyData</code> is a data type containing nothing. Use it if you do not want to attach any data to nodes. It is used by default when creating tree nodes. </li><li><code>MiscData</code> is a wrapper around <code>Dict</code>, allowing arbitrary data to be stored</li></ul><pre><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tree = parse_newick_string(&quot;((A:1,B:1)AB:2,C:3)R;&quot;, node_data_type = MiscData)</code><code class="nohighlight hljs ansi" style="display:block;">
                                                     _________________________ A
  __________________________________________________|
_|                                                  |_________________________ B
 |
 |____________________________________________________________________________ C</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = tree[&quot;A&quot;]</code><code class="nohighlight hljs ansi" style="display:block;">Node A:
Ancestor: AB, branch length = 1.0
0 children: String[]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(A)</code><code class="nohighlight hljs ansi" style="display:block;">TreeNode{MiscData}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dat = data(A)</code><code class="nohighlight hljs ansi" style="display:block;">MiscData(Dict{Any, Any}())</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dat[1] = 2; dat[&quot;Hello&quot;] = &quot;world!&quot;;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; data(A)</code><code class="nohighlight hljs ansi" style="display:block;">MiscData(Dict{Any, Any}(&quot;Hello&quot; =&gt; &quot;world!&quot;, 1 =&gt; 2))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; data(A)[&quot;Hello&quot;]</code><code class="nohighlight hljs ansi" style="display:block;">&quot;world!&quot;</code></pre><h3 id="Custom-data-type"><a class="docs-heading-anchor" href="#Custom-data-type">Custom data type</a><a id="Custom-data-type-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-data-type" title="Permalink"></a></h3><p>One can of course create arbitrary subtypes of <code>TreeNodeData</code>.  The only requirement for a custom data type <code>D</code> is that the call <code>D()</code> returns a valid instance of the type.  This is used when initially constructing the tree.  Below is an example of a custom <code>Sequence</code> type.  Note that if you actually want to use biological sequences, I encourage the use of the <a href="https://biojulia.net/BioSequences.jl/stable/">BioSequences.jl</a> package. </p><pre><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Base.@kwdef mutable struct Sequence &lt;: TreeNodeData # Create a custom data type
       	seq :: String = &quot;&quot;
       	seq_type :: Symbol = :dna
       end</code><code class="nohighlight hljs ansi" style="display:block;">Main.Sequence</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tree = parse_newick_string(&quot;((A:1,B:1)AB:2,C:3)R;&quot;, node_data_type = Sequence)</code><code class="nohighlight hljs ansi" style="display:block;">
                                                     _________________________ A
  __________________________________________________|
_|                                                  |_________________________ B
 |
 |____________________________________________________________________________ C</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(tree[&quot;C&quot;])</code><code class="nohighlight hljs ansi" style="display:block;">TreeNode{Main.Sequence}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; data!(tree[&quot;C&quot;], Sequence(seq = &quot;ACGT&quot;))</code><code class="nohighlight hljs ansi" style="display:block;">Main.Sequence(&quot;ACGT&quot;, :dna)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; data(tree[&quot;C&quot;]).seq</code><code class="nohighlight hljs ansi" style="display:block;">&quot;ACGT&quot;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; data(tree[&quot;C&quot;]).seq_type</code><code class="nohighlight hljs ansi" style="display:block;">:dna</code></pre><h2 id="Tree"><a class="docs-heading-anchor" href="#Tree">Tree</a><a id="Tree-1"></a><a class="docs-heading-anchor-permalink" href="#Tree" title="Permalink"></a></h2><p>In principle, access to one <code>TreeNode</code> object is enough to perform any operation on the tree.  However, in practice, it is often convenient to see the tree as a concept on its own, and not to see it through one of its nodes.  This is why TreeTools uses the <code>Tree</code> structure, which is basically a list of <code>TreeNode</code> objects.  <code>Tree</code> objects provide some specific methods: </p><ul><li><code>nodes</code> and <code>leaves</code> and <code>internals</code> respectively return iterators over all nodes, leaves and internal nodes of the tree, in an <em>arbitrary order</em></li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; println(&quot;Internal nodes: &quot;, map(label, internals(tree)))</code><code class="nohighlight hljs ansi" style="display:block;">Internal nodes: [&quot;R&quot;, &quot;AB&quot;]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; println(&quot;Leaves: &quot;, map(label, leaves(tree)))</code><code class="nohighlight hljs ansi" style="display:block;">Leaves: [&quot;B&quot;, &quot;A&quot;, &quot;C&quot;]</code></pre><ul><li>the call <code>tree[label]</code> will return the tree node with the corresponding label. Presence of a node in tree can be checked with <code>in(node, tree)</code> or <code>in(label, tree)</code></li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; in(&quot;AB&quot;, tree)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; in(tree[&quot;AB&quot;], tree)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; in(&quot;MyCat&quot;, tree)</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><ul><li><code>label</code> returns the name of the tree. It can be changed the <code>label!</code> method</li><li><code>root</code> returns the root of the tree</li></ul><p><code>Tree</code>s are construceted automatically from Newick strings when using functions such as <code>parse_newick_string</code> or <code>read_tree</code> (see <a href="../IO/#Reading-and-writing">Reading and writing</a>).  To construct a tree from a <code>Tree</code> from a <code>TreeNode</code>, use the <code>node2tree</code> function. Note that this is only intended to be used on root nodes: a warning will be produced if not. </p><pre><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; R = tree[&quot;R&quot;]</code><code class="nohighlight hljs ansi" style="display:block;">Node R (root)
Ancestor : `nothing` (root)
2 children: [&quot;AB&quot;, &quot;C&quot;]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tree2 = node2tree(R)</code><code class="nohighlight hljs ansi" style="display:block;">
                                                     _________________________ A
  __________________________________________________|
_|                                                  |_________________________ B
 |
 |____________________________________________________________________________ C</code></pre><div class="admonition is-warning"><header class="admonition-header">Copying a tree</header><div class="admonition-body"><p>The call <code>tree2 = node2tree(tree.root)</code> will produce another tree that shares nodes with <code>tree</code>.. This is usually not a good way to copy a tree, since the actual tree nodes are not copied. Any modification of the nodes of <code>tree</code> will also modify those of <code>tree2</code>. To make an independent copy, simply call <code>copy(tree)</code>. </p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../IO/">Reading and writing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 13 March 2023 13:03">Monday 13 March 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
