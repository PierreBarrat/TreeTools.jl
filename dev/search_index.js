var documenterSearchIndex = {"docs":
[{"location":"Iteration/#Iteration:-going-through-a-tree","page":"Iteration","title":"Iteration: going through a tree","text":"TreeTools offers two different ways to iterate through nodes: post/pre-order traversals, and arbitrary iteration. ","category":"section"},{"location":"Iteration/#Traversals","page":"Iteration","title":"Traversals","text":"The call traversal(tree, style) returns an iterator over the nodes of tree.  style can take two values: :preorder or :postorder.  The exact definition of the two traversals can be found here.  In short, the traversal guarantees that: \n\nfor :postorder (resp. :preorder), children nodes are always visited before (resp. after) parent nodes; \nthe order in which children of a node are visited is the same as that given in children(node);\nthe order is \"depth-first\": iteration over a subtree finishes before the next subtree starts. \n\njulia> tree = parse_newick_string(\"((A:1,B:1)AB:2,C:3)R;\");\n\njulia> map(label, traversal(tree, :postorder))\n5-element Vector{String}:\n \"A\"\n \"B\"\n \"AB\"\n \"C\"\n \"R\"\n\njulia> map(label, traversal(tree, :preorder))\n5-element Vector{String}:\n \"R\"\n \"AB\"\n \"A\"\n \"B\"\n \"C\"\n\njulia> map(label, traversal(tree, :postorder)) == map(label, traversal(tree)) # postorder is the default\ntrue\n\nOf course, this can also be used in a loop: \n\nusing TreeTools # hide \ntree = parse_newick_string(\"((A:1,B:1)AB:2,C:3)R;\"); # hide\nfor node in traversal(tree) # :postorder is the default\n\t# do something with `node`\nend\n\nNote that traversal can also be called on TreeNode objects:\n\njulia> map(label, traversal(tree, :preorder)) == map(label, traversal(root(tree), :preorder))\ntrue\n\nThe traversal function accepts boolean keyword arguments leaves, root and internals. If any of those is set to false, the corresponding nodes are skipped: \n\njulia> map(label, traversal(tree, :postorder, leaves=false))\n2-element Vector{String}:\n \"AB\"\n \"R\"\n\njulia> map(label, traversal(tree, :preorder, internals=false))\n3-element Vector{String}:\n \"A\"\n \"B\"\n \"C\"\n\nOne can also skip nodes by passing a function f as the first argument.  The traversal will only return nodes n such that f(n) is true: \n\njulia> map(label, traversal(n -> label(n)[1] == 'A', tree, :postorder))\n2-element Vector{String}:\n \"A\"\n \"AB\"","category":"section"},{"location":"Iteration/#map,-count,-etc...","page":"Iteration","title":"map, count, etc...","text":"In some cases, one wants to do something like count the number of nodes that have a given property, or apply some function f to each node and collect the result.  To facilitate this, TreeTools extends the Base functions map, map! and count to Tree and TreeNode objects.  Using these functions will traverse the tree in post-order.  If called on a TreeNode object, they will only iterate through the clade defined by this node. \n\nusing TreeTools # hide\ntree = parse_newick_string(\"((A:1,B:1)AB:2,C:3)R;\"); # hide\nmap(branch_length, tree) # Branch length of all nodes, in postorder\nmap!(tree) do node # Double the length of all branches - map! returns `nothing`\n\tx = branch_length(node)\n\tif !ismissing(x) branch_length!(node, 2*x) end\nend\nmap(branch_length, tree) # Doubled branch length, except for root (`missing`)\ncount(n -> label(n)[1] == 'A', tree) # count the nodes with a label starting with 'A'\n\nNote that there is a difference between the TreeTools extension of map! with respect Base: in TreeTools, map! returns nothing instead of an array. ","category":"section"},{"location":"Iteration/#Arbitrary-order","page":"Iteration","title":"Arbitrary order","text":"As explained in Basic concepts, a Tree object is mainly a dictionary mapping labels to TreeNode objects. We can thus iterate through nodes in the tree using this dictionary.  For this, TreeTools provides the nodes, leaves and internals methods.  This will traverse the tree in an arbitrary order but is faster than traversal.\n\nfor n in leaves(tree)\n\tprintln(\"$(label(n)) is a leaf\")\nend\nfor n in internals(tree)\n\tprintln(\"$(label(n)) is an internal node\")\nend\nmap(label, nodes(tree)) == union(\n\tmap(label, leaves(tree)), \n\tmap(label, internals(tree))\n)","category":"section"},{"location":"Iteration/#A-note-on-speed","page":"Iteration","title":"A note on speed","text":"Iterating through tree using nodes(tree) will be faster than using traversal(tree, ...). This is mainly because of my inability to write an efficient iterator (any help appreciated).  Below is a simple example where we define functions that count the number of nodes in a tree:\n\nusing TreeTools # hide\ncount_nodes_traversal(tree) = sum(x -> 1, traversal(tree, :postorder)) # Traversing the tree in post-order while summing 1\ncount_nodes_arbitrary(tree) = sum(x -> 1, nodes(tree)) # Arbitrary order\nnothing # hide\n\nThese two functions obviously give the same result, but not with the same run time. Here, we try it on the example/tree_10.nwk file: \n\ntree = read_tree(\"../../examples/tree_10.nwk\")\nusing BenchmarkTools\n@btime count_nodes_traversal(tree)\n@btime count_nodes_arbitrary(tree)\n\nBenchmarks show that this time difference tends to reduce when trees get larger (hundreds of leaves).  In any case, if a fast post/pre-order is needed, the only solution in the current state of TreeTools is to \"manually\" program it using a recursive function.   The code below defines a more efficient to count nodes, traversing the tree in post-order. \n\nfunction count_nodes_recursive(n::TreeNode) # this counts the number of nodes below `n`\n\tcnt = 0\n\tfor c in children(n)\n\t\tcnt += count_nodes_recursive(c) # \n\tend\n\treturn cnt + 1\nend\n\ncount_nodes_recursive(tree::Tree) = count_nodes_recursive(tree.root)\nnothing # hide\n\nThis will run faster than count_nodes_traversal, and does not allocate.  For counting nodes, this is really overkill, and one could just call length(nodes(tree)).  In particular, traversing the tree in a precise order does not matter at all.  But for more complex use case, writing short recursive code as above does not add a lot of complexity. \n\n@btime count_nodes_recursive(tree)","category":"section"},{"location":"basic_concepts/#Basic-concepts","page":"Basic concepts","title":"Basic concepts","text":"To introduce basic concepts and data structures used in TreeTools, we will use the small tree given by this Newick string: \"((A:1,B:1)AB:2,C:3)R;\". To obtain a tree from the string, run the following code in a julia REPL: \n\nusing TreeTools \nnwk = \"((A:1,B:1)AB:2,C:3)R;\"\ntree = parse_newick_string(nwk)","category":"section"},{"location":"basic_concepts/#TreeNode","page":"Basic concepts","title":"TreeNode","text":"At the basic level, the tree is represented by a set of linked TreeNode structures. A node n contains the following information: \n\nancestor(n) returns the node above n. If n is the root, ancestor(n) returns nothing. \nchildren(n) returns an array containing all the nodes below n. If n is a leaf, children(n) is empty. \nlabel(n) returns the label of n, which also serves as an identifier of n in many TreeTools functions. See the warning below. \nbranch_length(n) returns the length of the branch above n as a Float64. If n is the root or if it does not have a branch length, it returns missing. \ndata(n) returns data attached to n, see TreeNodeData\nisroot(n) and isleaf(n) are boolean functions with explicit behavior. \n\nwarning: Node labels\nTreeTools generally uses the label of nodes as an identifier. This is visible in the Tree structure which uses node labels for indexing. Another example is the equality between TreeNode objects n1 == n2, which simply falls back to label(n1) == label(n2). For this reason, it is strongly discouraged to directly change the label of a node, e.g. by doing something like n.label = mylabel. A function label! is provided for that, called like this: label!(tree, n, mylabel). This makes sure that the struct tree is informed about the label change. \n\ndanger: Loops in the tree\nTreeTools does not actively enforce the fact that trees do not have loops. That is, if you try to, you can perfectly create a state where e.g. a node is its own ancestor. This will of course result in a lot of issues. I'd like to enforce the absence of loops at some point, but for now it's up to the user to be careful.  \n\nThe illustration below is a summary of the TreeNode object.  (Image: TreeNode_illustration)\n\nEach TreeNode can be accessed by directly indexing into the tree: \n\nAB = tree[\"AB\"]\n\nTesting this on the above example would give: \n\nprintln(\"The ancestor of $(label(AB)) is $(label(ancestor(AB))), at distance $(branch_length(AB))\")\nprintln(\"Children of $(label(AB)): \", map(label, children(AB)))\nisleaf(AB)\nmap(isleaf, children(AB))\nisroot(ancestor(AB))\n\nChanging the value of the branch length or of the data attached to a node is done using the branch_length! and data! functions: \n\nbranch_length!(AB, 4.)\nprintln(\"The distance from $(label(AB)) to $(label(ancestor(AB))) is now $(branch_length(AB))\")\n\nnote: Branches\nTreeTools has no structure or type to represent branches.  Since only rooted trees are considered, it is natural for each node to \"own\" the branch above it.  As a result, informations about branches are expected  to be stored on the node below, as is the case for the branch length.","category":"section"},{"location":"basic_concepts/#TreeNodeData","page":"Basic concepts","title":"TreeNodeData","text":"TreeTools gives the possibility to attach data to nodes.  The TreeNode type is parametric: if data of type D is attached to a node, its type will be TreeNode{D}.  Children and ancestor of a TreeNode{D} object must also be of the TreeNode{D} type.  This implies that all nodes in the tree must have the same type of data attached to them. \n\nThe data type D has to be a subtype of the abstract type TreeNodeData.  The creation of nodes with a given data type is controlled by the node_data_type keyword argument in functions like parse_newick_string or read_tree (see the Reading and writing page).  Two subtypes of TreeNodeData are already implemented in TreeTools. \n\nEmptyData is a data type containing nothing. Use it if you do not want to attach any data to nodes. It is used by default when creating tree nodes. \nMiscData is a wrapper around Dict, allowing arbitrary data to be stored\n\nusing TreeTools # hide\ntree = parse_newick_string(\"((A:1,B:1)AB:2,C:3)R;\", node_data_type = MiscData)\nA = tree[\"A\"]\ntypeof(A)\ndat = data(A)\ndat[1] = 2; dat[\"Hello\"] = \"world!\";\ndata(A)\ndata(A)[\"Hello\"]","category":"section"},{"location":"basic_concepts/#Custom-data-type","page":"Basic concepts","title":"Custom data type","text":"One can of course create arbitrary subtypes of TreeNodeData.  The only requirement for a custom data type D is that the call D() returns a valid instance of the type.  This is used when initially constructing the tree.  Below is an example of a custom Sequence type.  Note that if you actually want to use biological sequences, I encourage the use of the BioSequences.jl package. \n\nusing TreeTools # hide\nBase.@kwdef mutable struct Sequence <: TreeNodeData # Create a custom data type\n\tseq :: String = \"\"\n\tseq_type :: Symbol = :dna\nend\ntree = parse_newick_string(\"((A:1,B:1)AB:2,C:3)R;\", node_data_type = Sequence)\ntypeof(tree[\"C\"])\ndata!(tree[\"C\"], Sequence(seq = \"ACGT\"))\ndata(tree[\"C\"]).seq\ndata(tree[\"C\"]).seq_type","category":"section"},{"location":"basic_concepts/#Tree","page":"Basic concepts","title":"Tree","text":"In principle, access to one TreeNode object is enough to perform any operation on the tree.  However, in practice, it is often convenient to see the tree as a concept on its own, and not to see it through one of its nodes.  This is why TreeTools uses the Tree structure, which is basically a list of TreeNode objects.  Tree objects provide some specific methods: \n\nnodes and leaves and internals respectively return iterators over all nodes, leaves and internal nodes of the tree, in an arbitrary order\n\nprintln(\"Internal nodes: \", map(label, internals(tree)))\nprintln(\"Leaves: \", map(label, leaves(tree)))\n\nthe call tree[label] will return the tree node with the corresponding label. Presence of a node in tree can be checked with in(node, tree) or in(label, tree)\n\nin(\"AB\", tree)\nin(tree[\"AB\"], tree)\nin(\"MyCat\", tree)\n\nlabel returns the name of the tree. It can be changed the label! method\nroot returns the root of the tree\n\nTrees are construceted automatically from Newick strings when using functions such as parse_newick_string or read_tree (see Reading and writing).  To construct a tree from a Tree from a TreeNode, use the node2tree function. Note that this is only intended to be used on root nodes: a warning will be produced if not. \n\nusing TreeTools # hide\ntree = parse_newick_string(\"((A:1,B:1)AB:2,C:3)R;\") # hide\nR = tree[\"R\"]\ntree2 = node2tree(R)\n\nwarning: Copying a tree\nThe call tree2 = node2tree(tree.root) will produce another tree that shares nodes with tree. This is usually not a good way to copy a tree, since the actual tree nodes are not copied. Any modification of the nodes of tree will also modify those of tree2. To make an independent copy, simply call copy(tree). ","category":"section"},{"location":"modifying_the_tree/#Modifying-the-tree","page":"Modifying the tree","title":"Modifying the tree","text":"On some occasions, it can be useful to modify a phylogenetic tree, e.g. removing some clades or branches.  TreeKnit offers a few methods for this: \n\nprune! and prunesubtree! for pruning a clade. \ngraft! for grafting a node onto a tree.\ninsert! for inserting an internal node on an existing branch of a tree. \ndelete! to delete an internal node while keeping the nodes below it. ","category":"section"},{"location":"modifying_the_tree/#Pruning","page":"Modifying the tree","title":"Pruning","text":"There are two functions to prune nodes: prune! and prunesubtree!.  They behave exactly the same except for the return value: prune! returns the prunde clade as a Tree object, while prunesubtree! just returns its root as a TreeNode object.  Both also return the previous ancestor of the pruned clade.  Let's see an example\n\nusing TreeTools # hide\ntree = parse_newick_string(\"(A:1.,(B:1.,(X1:0.,X2:0.)X:5.)BX:1.)R;\")\n\nLet's assume that we realized leaves X1 and X2 are really a weird outlier in our tree.  We want to get rid of them. \n\ntx, a = prune!(tree, \"X1\", \"X2\"); \ntx\ntree\n\nWhen called on a list of labels, prune! finds the MRCA of the input labels and prunes it from the tree.  Here, lca(tree, X1, X2) is internal node X, which is removed from the tree.  Note that cutting the branch above X will leave the internal node BX with a single child.  By default, prune! also removes singletons from the input tree.\n\nmap(label, nodes(tree)) # `BX` is not in there\n\nThis behavior can be changed with the remove_singletons keyword argument: \n\nlet\n\ttree = parse_newick_string(\"(A:1.,(B:1.,(X1:0.,X2:0.)X:5.)BX:1.)R;\")\n\tprune!(tree, \"X\"; remove_singletons=false)\n\tmap(label, nodes(tree))\nend\n\nThe prunesubtree! method does exactly the same as prune!, but returns the root of the pruned clade as a TreeNode, without converting it to a Tree.  Thus the two calls are equivalent: \n\nusing TreeTools # hide\ntree = parse_newick_string(\"(A:1.,(B:1.,(X1:0.,X2:0.)X:5.)BX:1.)R;\") # hide\ntx = prune!(tree, \"X\")[1] # or ... \ntree = parse_newick_string(\"(A:1.,(B:1.,(X1:0.,X2:0.)X:5.)BX:1.)R;\") # hide\ntx = let\n\tr, a = prunesubtree!(tree, \"X\")\n\tnode2tree(r)\nend","category":"section"},{"location":"modifying_the_tree/#Deleting-a-node","page":"Modifying the tree","title":"Deleting a node","text":"","category":"section"},{"location":"modifying_the_tree/#Grafting","page":"Modifying the tree","title":"Grafting","text":"","category":"section"},{"location":"modifying_the_tree/#Inserting-a-node","page":"Modifying the tree","title":"Inserting a node","text":"","category":"section"},{"location":"modifying_the_tree/#TreeNode-level-functions","page":"Modifying the tree","title":"TreeNode level functions","text":"All the methods above take a Tree as a first argument.  As described in Basic concepts, the actual information about the tree is contained in TreeNode objects, while the Tree is basically a wrapper around TreeNodes.  Thus, a method like prune! has to do two things: \n\ncut the ancestry relation between two TreeNode objects.\nupdate the Tree object in a consistent way. \n\nThe first part is where the \"actual\" pruning happens, and is done by the prunenode! function, which just takes a single TreeNode as input.  TreeTools has similar \"TreeNode level\" methods (not exported): \n\nprunenode!(n::TreeNode): cut the relation between n and its ancestor\ngraftnode!(r::TreeNode, n::TreeNode): graft n onto r. \ndelete_node!(n::TreeNode): delete cut the relation between n and its ancestor a, but re-graft the children of n onto a. \ninsert_node!(c, a, s, t): insert s::TreeNode between c and a, at height t on the branch. \n\nThese methods only act on TreeNode objects and do not care about the consistency with the Tree.  In most cases, it's more practical to call the Tree level methods.  However, if speed is important, it might be better to use them. ","category":"section"},{"location":"modifying_the_tree/#Other-useful-functions","page":"Modifying the tree","title":"Other useful functions","text":"","category":"section"},{"location":"modifying_the_tree/#Remove-singletons","page":"Modifying the tree","title":"Remove singletons","text":"remove_internal_singletons!","category":"section"},{"location":"modifying_the_tree/#Delete-insignificant-branches","page":"Modifying the tree","title":"Delete insignificant branches","text":"","category":"section"},{"location":"reference/","page":"-","title":"-","text":"Documentation for TreeTools.\n\n","category":"section"},{"location":"reference/#TreeTools.MiscData","page":"-","title":"TreeTools.MiscData","text":"struct MiscData <: TreeNodeData\n\tdat::Dict{Any,Any}\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/#TreeTools.Split","page":"-","title":"TreeTools.Split","text":"Split\n\ndat::Array{Int,1}: indices of leaves in the split\n\n\n\n\n\n","category":"type"},{"location":"reference/#TreeTools.SplitList","page":"-","title":"TreeTools.SplitList","text":"SplitList{T}\n\nleaves::Array{T,1}: labels of leaves\nsplits::Array{Split,1}\nmask::Array{Bool,1}: subset of leaves for which splits apply.\nsplitmap::Dict{T,Split}: indicate the split corresponding to the branch above a node. Only initialized if built from a tree with labels on internal nodes.\n\nConstructors\n\nSplitList(leaves::Array{T,1}) where T\n\nEmpty SplitList.\n\nSplitList(t::Tree[, mask])\n\nList of splits in t. mask defaults to ones.\n\nSplitList(r::TreeNode, leaves[, mask])\n\nCompute the list of splits below r, including r itself.   Assume that r is part of a tree with leaves. mask defaults to the set of leaves that are descendents   of r.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TreeTools.Tree","page":"-","title":"TreeTools.Tree","text":"mutable struct Tree{T <: TreeNodeData}\n\n\n\n\n\n","category":"type"},{"location":"reference/#TreeTools.TreeNode","page":"-","title":"TreeTools.TreeNode","text":"mutable struct TreeNode{T <: TreeNodeData}\n\nStructural information on the tree, i.e. topology and branch length.\n\nanc::Union{Nothing,TreeNode}: Ancestor\nchild::Array{TreeNode,1}: List of children\nisleaf::Bool\nisroot::Bool\ntau::Union{Missing, Float64}\ndata::T\n\n\n\n\n\n","category":"type"},{"location":"reference/#TreeTools.TreeNodeData","page":"-","title":"TreeTools.TreeNodeData","text":"abstract type TreeNodeData\n\nAbstract supertype for data attached to the dat field of TreeNode objects. Implemented concrete types are\n\nEmptyData: empty struct. Use if you do not have to attach data to nodes.\nMiscData: contains a dictionary for attaching extra data to nodes. Also behaves like  a Dict for indexing/iterating, e.g. x.dat[key] == x[key].\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.insert!-Union{Tuple{T}, Tuple{Tree{T}, TreeNode}} where T","page":"-","title":"Base.insert!","text":"insert!(tree, node; name, time)\n\nInsert a singleton named name above node, at height time on the branch. Return the inserted singleton. time can be a Number or missing.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.arecompatible-Tuple{Split, Split}","page":"-","title":"TreeTools.arecompatible","text":"arecompatible(s::Split, t::Split[, mask::Array{Bool}])\n\nAre splits s and t compatible in the cluster sense.\n\narecompatible(s::SplitList, i::Integer, j::Integer; mask=true)\n\nAre s.splits[i] and s.splits[j] compatible in the cluster sense?\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.branch_length!-Tuple{TreeNode, Union{Missing, Real}}","page":"-","title":"TreeTools.branch_length!","text":"branch_length!(n::TreeNode, τ)\n\nSet the branch length above n to τ.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.check_tree-Tuple{Tree}","page":"-","title":"TreeTools.check_tree","text":"check_tree(t::Tree; strict=true)\n\nEvery non-leaf node should have at least one child (two if strict)\nEvery non-root node should have exactly one ancestor\nIf n.child[...] == c, c.anc == n is true\nTree has only one root\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.data!-Union{Tuple{T}, Tuple{TreeNode{T}, T}} where T","page":"-","title":"TreeTools.data!","text":"data!(n::TreeNode{T}, dat::T)\n\nSet the the data field of n to dat.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.distance-Tuple{Tree, Tree}","page":"-","title":"TreeTools.distance","text":"distance(t1::Tree, t2::Tree; type = :RF, normalize = false)\n\nCompute distance between two trees. See TreeTools.tree_distance_types for allowed types. If normalize, the distance is normalized to [0,1].\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.distance-Tuple{TreeNode, TreeNode}","page":"-","title":"TreeTools.distance","text":"distance(t::Tree, n1::AbstractString, n2::AbstractString; topological=false)\ndistance(n1::TreeNode, n2::TreeNode; topological=false)\n\nCompute branch length distance between n1 and n2 by summing the branch_length values. If topological, the value 1. is summed instead, counting the number of branches separating the two nodes (Note: the output is not an Int!).\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.graft!-Union{Tuple{T}, Tuple{Tree{T}, TreeNode{T}, TreeNode}} where T","page":"-","title":"TreeTools.graft!","text":"graft!(tree::Tree, n, r; graft_on_leaf=false, time=branch_length(n))\n\nGraft n onto r and return the grafted node. r can be a label or a TreeNode, and should belong to tree. n can be a TreeNode or a Tree. In the latter case, n will be copied before being grafted. None of the nodes of the subtree of n should belong to tree.\n\nIf r is a leaf and graft_on_leaf is set to false (default), will raise an error.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.internals","page":"-","title":"TreeTools.internals","text":"nodes(t; skiproot=false)\nleaves(t)\ninternals(t; skiproot=false)\n\nIterator over all nodes / leaves / internal nodes of a tree. If skiproot, the root node will be skipped by the iterator.\n\nNote\n\nlength cannot be called on internals(t) as the latter is based on Iterators.filter.   A way to get the number of internal nodes of a tree is for example by calling   length(nodes(t)) - length(leaves(t)).\n\n\n\n\n\n","category":"function"},{"location":"reference/#TreeTools.is_ancestor-Tuple{TreeNode, TreeNode}","page":"-","title":"TreeTools.is_ancestor","text":"is_ancestor(t::Tree, a::AbstractString, n::AbstractString)\nis_ancestor(a::TreeNode, n::TreeNode)\n\nCheck if a is an ancestor of n, in the sense that ancestor(ancestor(...(node))) == a.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.iscompatible","page":"-","title":"TreeTools.iscompatible","text":"iscompatible(s::Split, S::SplitList, mask=S.mask; usemask=true)\n\nIs s compatible with all splits in S?\n\n\n\n\n\n","category":"function"},{"location":"reference/#TreeTools.isleaf-Tuple{Split}","page":"-","title":"TreeTools.isleaf","text":"isleaf(s::Split)\nisleaf(s::Split, mask::Array{Bool,1})\n\nCheck if s is a leaf split.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.isroot-Tuple{Split, Any}","page":"-","title":"TreeTools.isroot","text":"isroot(s::Split, mask::Array{Bool,1})\n\nCheck if s is the root split when restricted to mask.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.isroot-Tuple{SplitList, Any}","page":"-","title":"TreeTools.isroot","text":"isroot(S::SplitList, i)\n\nIs S[i] the root?\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.label!-Tuple{Tree, AbstractString}","page":"-","title":"TreeTools.label!","text":"label!(t::Tree, label::AbstractString)\n\nChange the label of the Tree to label.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.label!-Tuple{Tree, TreeNode, AbstractString}","page":"-","title":"TreeTools.label!","text":"label!(t::Tree, node::TreeNode, new_label::AbstractString)\nlabel!(t::Tree, old_label, new_label)\n\nChange the label of a TreeNode to new_label.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.lca-Tuple{Tree, Any}","page":"-","title":"TreeTools.lca","text":"lca(t::Tree, labels::Array{<:AbstractString,1})\nlca(t::Tree, labels...)\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.lca-Tuple{TreeNode, TreeNode}","page":"-","title":"TreeTools.lca","text":"lca(i_node::TreeNode, j_node::TreeNode)\n\nFind and return lowest common ancestor of i_node and j_node. Idea is to go up in the tree in an asymmetric way on the side of the deeper node, until both are at equal distance from root. Then, problem is solved by going up in a symmetric way. (https://stackoverflow.com/questions/1484473/how-to-find-the-lowest-common-ancestor-of-two-nodes-in-any-binary-tree/6183069#6183069)\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.lca-Tuple{Vararg{TreeNode}}","page":"-","title":"TreeTools.lca","text":"lca(nodelist)\n\nFind the common ancestor of all nodes in nodelist. nodelist is an iterable collection of TreeNode objects.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.leaves","page":"-","title":"TreeTools.leaves","text":"nodes(t; skiproot=false)\nleaves(t)\ninternals(t; skiproot=false)\n\nIterator over all nodes / leaves / internal nodes of a tree. If skiproot, the root node will be skipped by the iterator.\n\nNote\n\nlength cannot be called on internals(t) as the latter is based on Iterators.filter.   A way to get the number of internal nodes of a tree is for example by calling   length(nodes(t)) - length(leaves(t)).\n\n\n\n\n\n","category":"function"},{"location":"reference/#TreeTools.leaves-Tuple{SplitList, Any}","page":"-","title":"TreeTools.leaves","text":"leaves(S::SplitList, i)\n\nReturn array of leaves in S.splits[i], taking S.mask into account.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.node2tree-Union{Tuple{TreeNode{T}}, Tuple{T}} where T","page":"-","title":"TreeTools.node2tree","text":"node2tree(root::TreeNode{T}; label = default_tree_label(), force_new_labels=false)\n\nCreate a Tree object from root with name label. If force_new_labels, a random string is added to node labels to make them unique.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.node_depth-Tuple{TreeNode}","page":"-","title":"TreeTools.node_depth","text":"node_depth(node::TreeNode)\n\nTopologic distance from node to root.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.nodes","page":"-","title":"TreeTools.nodes","text":"nodes(t; skiproot=false)\nleaves(t)\ninternals(t; skiproot=false)\n\nIterator over all nodes / leaves / internal nodes of a tree. If skiproot, the root node will be skipped by the iterator.\n\nNote\n\nlength cannot be called on internals(t) as the latter is based on Iterators.filter.   A way to get the number of internal nodes of a tree is for example by calling   length(nodes(t)) - length(leaves(t)).\n\n\n\n\n\n","category":"function"},{"location":"reference/#TreeTools.parse_newick_string-Tuple{AbstractString}","page":"-","title":"TreeTools.parse_newick_string","text":"parse_newick_string(\n\tnw::AbstractString;\n\tnode_data_type=DEFAULT_NODE_DATATYPE, force_new_labels=false\n)\n\nParse newick string into a tree. See read_tree for more informations.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.postorder_traversal-Tuple{Function, TreeNode}","page":"-","title":"TreeTools.postorder_traversal","text":"postorder_traversal([f], tree; root=true, leaves=true, internals=true)\n\nTraverse tree in postorder, iterating over nodes. The children of node are returned in the same order as children(node).\n\nKeep only nodes n such that f(n) is true. If leaves, internals or root are set to false, the corresponding nodes are excluded.\n\nExamples\n\nfor node in postorder_traversal(tree; root=false)\n    isroot(node) # always false\nend\n\n[label(x) for x in postorder_traversal(tree; internals=false)] # labels of leaf nodes\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.print_tree_ascii-Tuple{Any, Tree}","page":"-","title":"TreeTools.print_tree_ascii","text":"print_tree_ascii(io, t::Tree)\n\nJulia implementation of Bio.Phylo.drawascii function:  https://github.com/biopython/biopython/blob/master/Bio/Phylo/utils.py\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.prune!-Tuple{Any, Any}","page":"-","title":"TreeTools.prune!","text":"prune!(tree, node; kwargs...)\nprune!(tree, labels::AbstractArray)\nprune!(tree, labels...)\n\nPrune node from tree. node can be a label or a TreeNode. Return the subtree defined by node as a Tree object as well as the previous ancestor of node.\n\nIf a list of labels is provided, the MRCA of the corresponding nodes is pruned.\n\nkwargs\n\nremove_singletons: remove singletons (internals with one child) in the tree after pruning. Default true.\nclade_only: if a list of labels is provided, check that it corresponds to a clade before pruning. Default true.\ncreate_leaf: if the ancestor of r has only one child (singleton), pruning r  will create a leaf. If create_leaf == :warn, this will trigger a warning. If  create_leaf = false, it will trigger an error. If create_leaf = true, then this  is allowed. Default: :warn.\n\nExample\n\nusing TreeTools # hide\ntree = parse_newick_string(\"(A:1.,(B:1.,(X1:0.,X2:0.)X:5.)BX:1.)R;\")\nprune!(tree, [\"X1\", \"X2\"])\nmap(label, nodes(tree))\n\n# output\n\n3-element Vector{String}:\n \"B\"\n \"A\"\n \"R\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.read_tree-Tuple{IO}","page":"-","title":"TreeTools.read_tree","text":"read_tree(\n\tnwk_filename::AbstractString;\n\tnode_data_type=DEFAULT_NODE_DATATYPE,\n    label,\n    force_new_labels=false,\n    check=true,\n)\nread_tree(io::IO; kwargs...)\n\nRead Newick file and create a Tree{node_data_type} object from it. If the input file contains multiple Newick strings on different lines, the output is an array of Tree objects.\n\nThe call node_data_type() must return a valid instance of a subtype of TreeNodeData. You can implement your own subtypes, or see ?TreeNodeData for already implemented ones. The default is EmptyData.\n\nUse force_new_labels=true to force the renaming of all internal nodes. By default the tree will be assigned a label by calling default_tree_label(). This can be changed using the label argument.\n\nIf you have a variable containing a Newick string and want to build a tree from it, use parse_newick_string instead.\n\nNote on labels\n\nThe Tree type identifies nodes by their labels. This means that labels have to be unique. For this reason, the following is done when reading a tree:\n\nif an internal node does not have a label, a unique one will be created of the form  \"NODE_i\"\nif a node has a label that was already found before in the tree, a random identifier  will be appended to it to make it unique. Note that the identifier is created using  randstring(8), unicity is technically not guaranteed.\nif force_new_labels is used, a unique identifier is appended to node labels\nif node labels in the Newick file are identified as confidence/bootstrap values, a random  identifier is appended to them, even if they're unique in the tree. See  ?TreeTools.isbootstrap to see which labels are identified as confidence values.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.root!-Tuple{Any}","page":"-","title":"TreeTools.root!","text":"root!(tree; method=:midpoint, topological = false)\n\nRoot tree using method. Only implemented method is :midpoint. \n\nMethods\n\n:midpoint\n\nDistance between nodes can be either topological (number of branches) or based on branch length. Does not create a polytomy at the root: if the midpoint is an already existing internal node (not the root), creates a new root node at infinitesimal distance below it.\n\nMidpoint rooting will exit without doing anything if\n\nthe distance between the two farthest leaves is 0. This happens if all branch lengths  are 0.\nthe current root is already the midpoint.\n\n:model\n\nProvide keyword argument model::Tree. Try to root tree like model. If the two trees only differ by rooting, they will have the same topology at the end of this. Else, tree will be rerooted but a warning will be given.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.root!-Tuple{Tree, AbstractString}","page":"-","title":"TreeTools.root!","text":"root!(tree::Tree, node::AbstractString; root_on_leaf, time=0., remove_singletons=true)\n\nRoot tree at tree.lnodes[node]. Equivalent to outgroup rooting. If time is non-zero, root above node at height time, inserting a new node.\n\nIf remove_singletons, singleton nodes are removed after re-rooting. This is useful to remove the old root, which often ends up being a singleton.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.share_labels-Tuple{Any, Any}","page":"-","title":"TreeTools.share_labels","text":"share_labels(tree1, tree2)\n\nCheck if tree1 and tree2 share the same labels for leaf nodes.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.traversal","page":"-","title":"TreeTools.traversal","text":"traversal([f], tree, style=:postorder; internals, leaves, root)\ntraversal([f], node, style=:postorder; internals, leaves, root)\n\nIterate through nodes of tree according to style, skipping nodes for which f returns false. style must be in collect(keys(TreeTools.traversal_styles)). For now its just :postorder.\n\nSee postorder_traversal for extended docstring.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TreeTools.write_newick-Tuple{IO, Tree}","page":"-","title":"TreeTools.write_newick","text":"write_newick(io::IO, tree::Tree; kwargs...)\nwrite_newick(filename::AbstractString, tree::Tree, mode=\"w\"; kwargs...)\nwrite_newick(tree::Tree; kwargs...)\n\nWrite Newick string corresponding to tree to io or filename. If output is not provided, return the Newick string. If internal_labels == false, do not write labels of internal nodes in the string.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.write_newick-Tuple{Tree}","page":"-","title":"TreeTools.write_newick","text":"newick(tree::Tree; internal_labels=true, write_root=true)\n\nReturn the Newick string correpsonding to tree. If internal_labels == false, do not write labels of internal nodes in the string. If !write_root, do not write label and time for the root node (unrooted tree).\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.Generate.YuleCoalescent","page":"-","title":"TreeTools.Generate.YuleCoalescent","text":"mutable struct YuleCoalescent\n\nn::Int = 2\nb::Float64 = 1 # birth rate\n\nRate of coalescence (n-1)b. The expected height of the tree is (I think) ~log(n)/b\n\n\n\n\n\n","category":"type"},{"location":"reference/#TreeTools.Generate.balanced_binary_tree","page":"-","title":"TreeTools.Generate.balanced_binary_tree","text":"balanced_binary_tree(n::Integer, time::Union{Missing, Real} = missing)\n\nReturn a balanced binary tree of n nodes with all branches of length time. n must be a power of 2.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TreeTools.Generate.birth_death-Tuple{Integer, Real, Real}","page":"-","title":"TreeTools.Generate.birth_death","text":"birth_death(n::Integer, λ::Real, μ::Real; active=false, warn_incomplete=true)\n\nSimulate a birth death process with rates λ (birth) and μ (death). Stop when there are n lineages. Return the a Tree and a boolean indicating completion of the process: it is false if all lineages died before reaching the target n.\n\nKeyword argument active (default: false) controls whether only active lineages (i.e. non dead) count towards completion. If active=false, the number of leaves of output tree is n if the process completed. If active=true, it is larger than n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.Generate.genealogy-Tuple{TreeTools.Generate.Coalescent}","page":"-","title":"TreeTools.Generate.genealogy","text":"genealogy(C::Coalescent; coalescence_times = false)\n\nReturn a tree sampled from the coalescent C. If coalescence_times, also return the times Tn during which n lineages are present, in the form of a dictionary n => Tn.\n\nExamples\n\nFor the Kingman coalescent with population size N and n=100 lineages:\n\ntree = genealogy(KingmanCoalescent(100, N))\n\n\n\n\n\n","category":"method"},{"location":"reference/#TreeTools.Generate.ladder_tree","page":"-","title":"TreeTools.Generate.ladder_tree","text":"ladder_tree(n[, t=missing])\n\nReturn a ladder tree with n leaves with total height t. For 4 leaves A, B, C, D, this would be (A:t,(B:2t/3,(C:t/3,D:t/3)));. The elementary branch length is t/(n-1) if n>1.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TreeTools.Generate.star_tree","page":"-","title":"TreeTools.Generate.star_tree","text":"star_tree(n, times)\n\nCreate a star tree with n leaves. times can be an iterable of length n or a number/missing.\n\n\n\n\n\n","category":"function"},{"location":"generating_trees/#Generating-trees","page":"Generating trees","title":"Generating trees","text":"TreeTools has three ways to generate trees: \n\nusing a birth-death process (i.e. forward simulation);\nusing a coalescent process (i.e. backward simulation);\nusing a collection of pre-defined simple shapes. \n\nAll three methods are accessible through the TreeTools.Generate submodule.  For now, this is not exported: most functions below need to be prefaced by an explicit TreeTools.Generate. ","category":"section"},{"location":"generating_trees/#Birth-death-process","page":"Generating trees","title":"Birth-death process","text":"This is rather straightforward: \n\nusing TreeTools # hide\nbegin\n\tn = 25 # number of lineages to reach for completion\n\tb = 1 # birth rate\n\td = 0.1 # death rate\nend;\ntree, completed = TreeTools.Generate.birth_death(n, b, d)\nlength(leaves(tree)) == n || !completed\n\nThe second output argument completed is a boolean indicating whether the process reached the target n lineages. If the death rate is non-zero, it is possible that all lineages die before completion. \n\nThe implemented process starts with one lineage (the root).  Then, if there are n lineages in the tree: \n\nwith rate bcdot n, trigger a birth event: pick a lineage at random and split it in two;\nwith rate dcdot n, trigger a death event: stop the lineage and place a leaf at its end;\nif n reaches the target value for completion or if all lineages are dead, stop the process by placing a leaf at the end of each lineage.","category":"section"},{"location":"generating_trees/#Coalescent-process","page":"Generating trees","title":"Coalescent process","text":"There are two coalescent models implemented. \n\nThe classical Kingman's process, with a rate of coalescence nu = n(n-1)N for n lineages, where N is a parameter (the population size).\nThe Yule process, with a rate of coalescence nu = bcdot n for n lineages, where b can be interpreted as a birth rate. This is equivalent to a birth only forward process. \n\nGenerating a coalescent tree is a two-step process: first construct a Coalescent object, then give it to the function genealogy. \n\nusing TreeTools # hide\nkingman = TreeTools.Generate.KingmanCoalescent(n=25, N=10_000)\nyule = TreeTools.Generate.YuleCoalescent(n=5, b=1)\ntree = TreeTools.Generate.genealogy(kingman)\ndistance(root(tree), first(leaves(tree))) # ~2N on average\ntree = TreeTools.Generate.genealogy(yule)\ndistance(root(tree), first(leaves(tree))) # ~b log(n) on average\n\nIt is possible to create custom coalescent.  Below, we create a backward process with multiple mergers, with the following properties: \n\nthe rate of merging is rho, independent of the number of lineages n;\nwhen a merge occurs, an average fraction beta of the n lineages is involved (sampled using a binomial). \n\nFirst, we define the corresponding coalescent type.  Importantly, the field n must be present in the struct, and is interpreted as the number of remaining lineages. \n\nusing TreeTools # hide\n@kwdef mutable struct MultipleMerger <: TreeTools.Generate.Coalescent\n    n::Int # number of lineages\n    β::Float64 # parameters \n    ρ::Float64\nend\n\nNow, we need to define the choose_event function that samples a merge event from this process. The return value should be a tuple k, t with k being the number of lineages involved in the merge and t the time to the event. \n\nusing Distributions\nimport TreeTools.Generate.choose_event\nfunction choose_event(C::MultipleMerger)\n    C.n <= 1 &&  throw(ArgumentError(\"Cannot choose coalescence event for $(C.n) lineage.\"))\n    t = 0.\n    merger = 0\n    coin = Binomial(C.n, C.β) # this is from Distributions, \n    while merger < 2\n        t += rand(Exponential(1/C.ρ))\n        merger = rand(coin)\n    end\n    return merger, t\nend\n\nNow we can sample from this\n\nmm = MultipleMerger(n=15, β=.25, ρ=1)\ntree = TreeTools.Generate.genealogy(mm)\nusing StatsBase\nmap(n -> length(children(n)), internals(tree)) |> countmap # if we're not unlucky, there should be some multiple mergers in here! ","category":"section"},{"location":"generating_trees/#Basic-shapes","page":"Generating trees","title":"Basic shapes","text":"There are three at the moment, with self explanatory names: \n\nusing TreeTools # hide\nstar = TreeTools.Generate.star_tree(4, 1.)\nladder = TreeTools.Generate.ladder_tree(4, 1.)\nbalanced = TreeTools.Generate.balanced_binary_tree(4, 1.)\n\nThe docstrings give a bit more detail. ","category":"section"},{"location":"#TreeTools.jl","page":"Home","title":"TreeTools.jl","text":"TreeTools is a package to allow manipulation and simple operations on rooted phylogenetic or genealogic trees.  It started off as a dependency of another package TreeKnit, but can in principle be used for any problem involving trees. ","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"You can simply install TreeTools using the julia package manager (if you don't have julia, you can get it from here): \n\nusing Pkg\nPkg.add(\"TreeTools\")\n\nYou should now be able to use using TreeKnit from inside julia and follow the rest of the documentation. \n\ninfo: Info\nThe documentation is being written: more things to come! ","category":"section"},{"location":"useful_functions/#Useful-functions","page":"Useful functions","title":"Useful functions","text":"","category":"section"},{"location":"useful_functions/#Copy,-convert","page":"Useful functions","title":"Copy, convert","text":"To make an independent copy of a tree, simply call copy. \n\nusing TreeTools # hide\ntree = parse_newick_string(\"((A:1,B:1)AB:2,C:3)R;\");\ntree_copy = copy(tree);\nlabel!(tree_copy, \"A\", \"Alfred\") # relabel node A\ntree_copy\ntree\n\nThe convert function allows one to change the data type attached to nodes: \n\ntypeof(tree)\ndata(tree[\"A\"])\ntree_with_data = convert(Tree{MiscData}, tree);\ntypeof(tree_with_data)\ndata(tree_with_data[\"A\"])[\"Hello\"] = \" world!\"","category":"section"},{"location":"useful_functions/#MRCA,-divergence-time","page":"Useful functions","title":"MRCA, divergence time","text":"The most recent common ancestor between two nodes or more is found using the function lca: \n\nlca(tree[\"A\"], tree[\"B\"]) # simplest form\nlca(tree, \"A\", \"B\") # lca(tree, labels...)\nlca(tree, \"A\", \"B\", \"C\") # takes a variable number of labels as input\nlca(tree, \"A\", \"AB\") # This is not restricted to leaves\n\nTo compute the distance or divergence time between two tree nodes, use distance.  The topological keyword allows computing the number of branches separating two nodes. \n\ndistance(tree, \"A\", \"C\")\ndistance(tree[\"A\"], tree[\"C\"]; topological=true) \n\nThe function is_ancestor tells you if one node is found among the ancestors of another.  This uses equality between TreeNode, which simply compares labels, see Basic concepts\n\nis_ancestor(tree, \"A\", \"C\")\nis_ancestor(tree, \"R\", \"A\")","category":"section"},{"location":"useful_functions/#Distance-between-trees","page":"Useful functions","title":"Distance between trees","text":"The distance function also lets you compute the distance between two trees.  For now, only the Robinson-Foulds distance is implemented, but more could come. \n\njulia> t1 = parse_newick_string(\"((A,B,D),C);\");\n\njulia> t2 = parse_newick_string(\"((A,(B,D)),C);\");\n\njulia> distance(t1, t2)\n1\n\njulia> round(distance(t1, t2; normalize=true), sigdigits=2)\n0.33","category":"section"},{"location":"IO/#Reading-and-writing","page":"Reading and writing","title":"Reading and writing","text":"For now, TreeTools only handles the Newick format.  Functions are quite basic at this stage. ","category":"section"},{"location":"IO/#Reading","page":"Reading and writing","title":"Reading","text":"To read from a Newick file, use read_tree.  Here is an example with the example/tree_10.nwk file: \n\nusing TreeTools # hide\ntree = read_tree(\"../../examples/tree_10.nwk\")\n\nThe documentation reproduced below gives more information: \n\nread_tree will also read files containing several Newick strings, provided they are on separate lines.  It then returns an array of Tree objects. \n\nIf you have a variable containing a Newick string, simply call parse_newick_string to return a tree: \n\nusing TreeTools # hide\nnwk = \"(A:3,(B:1,C:1)BC:1);\"\ntree = parse_newick_string(nwk)\n\nIf internal nodes of a Newick string do not have names, TreeTools will by default give them names of the form NODE_i with i::Int.  This happens during parsing of the Newick string, in the parse_newick! function.  This label is technically not guaranteed to be unique: the Newick string may also contain nodes with the same name.  In some cases, it is thus necessary to create a unique identifier for a node.  This is done by creating a random string obtained with the call Random.randstring(8), and happens at a later stage, when calling the node2tree function (see the section about Tree).  This happens when: \n\nthe node label is found to be a bootstrap value (see ?TreeTools.isbootstrap). \nthe option force_new_labels is used when calling read_tree. This is useful if some internal nodes of the Newick string have redundant names. \nfor some reason, the node does not yet have a label. \n\nThere are about 2cdot 10^14 strings of length 8 (alphabetic + numeric characters), so this should be fine for most problems. A quick calculation shows that for a tree of 1000 leaves, the probability of obtaining two equal identifiers for different nodes is sim 2 cdot 10^-9, which is probably acceptable for most applications. If you think it's not enough, I can add a handle to let user create longer strings, or solve this in a more elegant way. ","category":"section"},{"location":"IO/#Writing","page":"Reading and writing","title":"Writing","text":"To write t::Tree to a Newick file, simply call write(filename, t).  If you want to append to a file, call write(filename, t, \"a\").  Note that write(filename, t) adds a newline '\\n' character at the end of the Newick string.  This is done in case other trees have to be added to the file. ","category":"section"},{"location":"IO/#TreeTools.read_tree","page":"Reading and writing","title":"TreeTools.read_tree","text":"read_tree(\n\tnwk_filename::AbstractString;\n\tnode_data_type=DEFAULT_NODE_DATATYPE,\n    label,\n    force_new_labels=false,\n    check=true,\n)\nread_tree(io::IO; kwargs...)\n\nRead Newick file and create a Tree{node_data_type} object from it. If the input file contains multiple Newick strings on different lines, the output is an array of Tree objects.\n\nThe call node_data_type() must return a valid instance of a subtype of TreeNodeData. You can implement your own subtypes, or see ?TreeNodeData for already implemented ones. The default is EmptyData.\n\nUse force_new_labels=true to force the renaming of all internal nodes. By default the tree will be assigned a label by calling default_tree_label(). This can be changed using the label argument.\n\nIf you have a variable containing a Newick string and want to build a tree from it, use parse_newick_string instead.\n\nNote on labels\n\nThe Tree type identifies nodes by their labels. This means that labels have to be unique. For this reason, the following is done when reading a tree:\n\nif an internal node does not have a label, a unique one will be created of the form  \"NODE_i\"\nif a node has a label that was already found before in the tree, a random identifier  will be appended to it to make it unique. Note that the identifier is created using  randstring(8), unicity is technically not guaranteed.\nif force_new_labels is used, a unique identifier is appended to node labels\nif node labels in the Newick file are identified as confidence/bootstrap values, a random  identifier is appended to them, even if they're unique in the tree. See  ?TreeTools.isbootstrap to see which labels are identified as confidence values.\n\n\n\n\n\n","category":"function"}]
}
